#include "ns3/core-module.h"
#include "ns3/internet-module.h"
#include "ns3/network-module.h"
#include "ns3/point-to-point-module.h"

#include <fstream>
#include <sstream>
#include <stdexcept>
#include <string>

using namespace ns3;

NS_LOG_COMPONENT_DEFINE("utils");

Mac48Address
convertToMacAddress(Address address)
{
    Mac48Address senderMacAddress = Mac48Address();
    senderMacAddress = senderMacAddress.ConvertFrom(address);
    return senderMacAddress;
}

std::string
getPath(std::string directory, std::string file)
{
    return SystemPath::Append(directory, file);
}

void
addIpv4Address(Ptr<Node> host5,
                NetDeviceContainer host5Interfaces,
                std::string address,
                std::string netmask)
{
    Ptr<Ipv4> ipv4Host = host5->GetObject<Ipv4>();
    uint32_t ifaceIndex = ipv4Host->GetInterfaceForDevice(host5Interfaces.Get(0));
    Ipv4Address addr = Ipv4Address(address.c_str());
    Ipv4Mask mask = Ipv4Mask(netmask.c_str());
    Ipv4InterfaceAddress ifaceAddress = Ipv4InterfaceAddress(addr, mask);
    ipv4Host->AddAddress(ifaceIndex, ifaceAddress);
    ipv4Host->SetUp(ifaceIndex);
}

void
addIpv4ArpEntry(Ptr<Ipv4Interface> interface, Ipv4Address ipv4Address, Mac48Address macAddress)
{
    Ptr<ArpCache> arpCache = interface->GetArpCache();
    ArpCache::Entry* entry = arpCache->Lookup(ipv4Address);
    if (!entry)
    {
        NS_LOG_DEBUG("Add ARP Entry for " << "(" << ipv4Address << ", " << macAddress << ")");
        entry = arpCache->Add(ipv4Address);
    }
    entry->SetMacAddress(macAddress);
    entry->MarkAutoGenerated();
}

Ptr<Ipv4Interface>
getIpv4Interface(Ptr<NetDevice> netDevice)
{
    Ptr<Node> node = netDevice->GetNode();
    int32_t interface_index = node->GetObject<Ipv4>()->GetInterfaceForDevice(netDevice);
    return node->GetObject<Ipv4L3Protocol>()->GetInterface(interface_index);
}

void
printRoutes(Ptr<Ipv4StaticRouting> routing)
{
    for (uint32_t i = 0; i < routing->GetNRoutes(); i++)
    {
        std::ostringstream oss;
        oss << routing->GetRoute(i);
        std::cout << oss.str() << std::endl;
    }
}

void
addArpEntriesFromInterfaceAddresses(Ptr<Ipv4Interface> nodeInterface,
                                    Ptr<Ipv4Interface> ipv4Interface)
{
    Ipv4StaticRoutingHelper ipv4StaticRouting;
    Ptr<Ipv4StaticRouting> routing = ipv4StaticRouting.GetStaticRouting(
        nodeInterface->GetDevice()->GetNode()->GetObject<Ipv4>());
    for (uint32_t i = 0; i < ipv4Interface->GetNAddresses(); i++)
    {
        Ipv4Address address = ipv4Interface->GetAddress(i).GetAddress();
        addIpv4ArpEntry(nodeInterface,
                        address,
                        convertToMacAddress(ipv4Interface->GetDevice()->GetAddress()));

        routing->AddHostRouteTo(address, 1);
    }

    std::ostringstream oss;
    oss << "Routes for " << Names::FindName(nodeInterface->GetDevice()->GetNode()) << std::endl;
    for (uint32_t i = 0; i < routing->GetNRoutes(); i++)
    {
        oss << routing->GetRoute(i) << std::endl;
    }
    NS_LOG_DEBUG(oss.str());
}

std::string
loadCommands(std::string path)
{
    std::ifstream commandFile(path);
    std::ostringstream commands;

    if (!commandFile)
    {
        throw std::runtime_error("Failed to open commands file: " + path);
    }

    std::string line;
    while (std::getline(commandFile, line))
    {
        commands << line << "\n";
    }

    return commands.str();
}

void
printSimulationTime()
{
    std::cout << "Simulation Time: " << Simulator::Now().GetSeconds() << std::endl;
    Simulator::Schedule(Seconds(1), printSimulationTime);
}
