/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#include "ns3/applications-module.h"
#include "ns3/core-module.h"
#include "ns3/csma-module.h"
#include "ns3/flow-monitor-helper.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/internet-module.h"
#include "ns3/network-module.h"
#include "ns3/p4-switch-module.h"

#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <random>
#include <string>

using namespace ns3;

NS_LOG_COMPONENT_DEFINE("QLRoutingExample");

bool verbose = false;

uint32_t seed = 10;
std::mt19937 randomGen;
std::uniform_real_distribution distribution;

Mac48Address
convertToMacAddress(Address address)
{
    Mac48Address senderMacAddress = Mac48Address();
    senderMacAddress = senderMacAddress.ConvertFrom(address);
    return senderMacAddress;
}

void
addIpv4ArpEntry(Ptr<Ipv4Interface> interface, Ipv4Address ipv4Address, Mac48Address macAddress)
{
    Ptr<ArpCache> arpCache = interface->GetArpCache();
    ArpCache::Entry* entry = arpCache->Lookup(ipv4Address);
    if (!entry)
    {
        if (verbose)
        {
            NS_LOG_INFO("Add ARP Entry for " << "(" << ipv4Address << ", " << macAddress << ")");
        }
        entry = arpCache->Add(ipv4Address);
    }
    entry->SetMacAddress(macAddress);
    entry->MarkAutoGenerated();
}

ApplicationContainer
createTcpApplication(Ipv4Address addressToReach,
                     uint16_t port,
                     Ptr<Node> node,
                     std::string dataRate,
                     uint32_t maxBytes,
                     std::string congestionControl)
{
    TypeId congestionControlTid = TypeId::LookupByName(congestionControl);

    Config::Set("/NodeList/" + std::to_string(node->GetId()) + "/$ns3::TcpL4Protocol/SocketType",
                TypeIdValue(congestionControlTid));

    OnOffHelper source("ns3::TcpSocketFactory", Address(InetSocketAddress(addressToReach, port)));
    source.SetConstantRate(DataRate(dataRate), 1400);
    // source.SetAttribute("DataRate", StringValue(dataRate));
    source.SetAttribute("MaxBytes", UintegerValue(maxBytes));
    // source.SetAttribute("SendSize", UintegerValue(1400));

    return source.Install(node);
}

ApplicationContainer
createSinkTcpApplication(uint16_t port, Ptr<Node> node)
{
    PacketSinkHelper sink("ns3::TcpSocketFactory",
                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));
    return sink.Install(node);
}

void
startTcpFlow(Ptr<Node> receiverHost,
             std::vector<Ptr<Ipv4Interface>> receiverInterfaces,
             Ptr<Node> senderHost,
             uint16_t port,
             std::string activeRateTcp,
             uint32_t tcpDataSize)
{
    ApplicationContainer hostReceiverApp = createSinkTcpApplication(port, receiverHost);
    hostReceiverApp.Start(Seconds(0.0));

    ApplicationContainer hostSenderApp =
        createTcpApplication(receiverInterfaces[0]->GetAddress(0).GetAddress(),
                             port,
                             senderHost,
                             activeRateTcp,
                             tcpDataSize,
                             "ns3::TcpCubic");
    hostSenderApp.Start(Seconds(1.0));
}

ApplicationContainer
createUdpApplication(Ipv4Address addressToReach,
                     uint16_t port,
                     Ptr<Node> node,
                     std::string dataRate,
                     uint32_t flowStartTime,
                     uint32_t flowEndTime,
                     uint32_t maxBytes,
                     bool generateRandom)
{
    OnOffHelper source("ns3::UdpSocketFactory", Address(InetSocketAddress(addressToReach, port)));
    source.SetConstantRate(DataRate(dataRate), 1400);
    source.SetAttribute("MaxBytes", UintegerValue(maxBytes));

    ApplicationContainer senderApp = source.Install(node);

    double startTime = flowStartTime;
    double endTime = flowEndTime;
    if (generateRandom)
    {
        startTime = distribution(randomGen);
        std::uniform_real_distribution endDistribution(startTime + 0.3, (double)flowEndTime);
        endTime = endDistribution(randomGen);
    }
    NS_LOG_INFO("UDP Application: " + std::to_string(startTime) + " - " + std::to_string(endTime));
    senderApp.Start(Seconds(startTime));
    senderApp.Stop(Seconds(endTime));

    return senderApp;
}

ApplicationContainer
createSinkUdpApplication(uint16_t port, Ptr<Node> node)
{
    PacketSinkHelper sink("ns3::UdpSocketFactory",
                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));
    return sink.Install(node);
}

void
startUdpFlow(Ptr<Node> receiverHost,
             std::vector<Ptr<Ipv4Interface>> receiverInterfaces,
             Ptr<Node> senderHost,
             uint16_t port,
             std::string backupRateUdp,
             uint32_t start_time,
             uint32_t end_time,
             uint32_t udpDataSize,
             bool generateRandom)
{
    ApplicationContainer hostReceiverApp = createSinkUdpApplication(port, receiverHost);
    hostReceiverApp.Start(Seconds(0.0));

    ApplicationContainer hostSenderApp =
        createUdpApplication(receiverInterfaces[0]->GetAddress(0).GetAddress(),
                             port,
                             senderHost,
                             backupRateUdp,
                             start_time,
                             end_time,
                             udpDataSize,
                             generateRandom);
    hostSenderApp.Start(Seconds(1.0));
}

Ptr<Ipv4Interface>
getIpv4Interface(Ptr<NetDevice> netDevice)
{
    Ptr<Node> node = netDevice->GetNode();
    int32_t interface_index = node->GetObject<Ipv4>()->GetInterfaceForDevice(netDevice);
    return node->GetObject<Ipv4L3Protocol>()->GetInterface(interface_index);
}

void
printRoutes(Ptr<Ipv4StaticRouting> routing)
{
    for (uint32_t i = 0; i < routing->GetNRoutes(); i++)
    {
        std::ostringstream oss;
        oss << routing->GetRoute(i);
        std::cout << oss.str() << std::endl;
    }
}

void
addArpEntriesFromInterfaceAddresses(Ptr<Ipv4Interface> nodeInterface,
                                    Ptr<Ipv4Interface> ipv4Interface)
{
    Ipv4StaticRoutingHelper ipv4StaticRouting;
    Ptr<Ipv4StaticRouting> routing = ipv4StaticRouting.GetStaticRouting(
        nodeInterface->GetDevice()->GetNode()->GetObject<Ipv4>());
    for (uint32_t i = 0; i < ipv4Interface->GetNAddresses(); i++)
    {
        Ipv4Address address = ipv4Interface->GetAddress(i).GetAddress();
        addIpv4ArpEntry(nodeInterface,
                        address,
                        convertToMacAddress(ipv4Interface->GetDevice()->GetAddress()));

        routing->AddHostRouteTo(address, 1);
    }

    if (verbose)
    {
        std::cout << "Routes for " << Names::FindName(nodeInterface->GetDevice()->GetNode())
                  << std::endl;
        printRoutes(routing);
    }
}

void
addIpv4Address(Ptr<Ipv4Interface> ipv4Interface, Ipv4AddressHelper* ipv4AddressHelper)
{
    Ipv4Address address = ipv4AddressHelper->NewAddress();
    if (verbose)
    {
        NS_LOG_INFO("Add IPv4 Address: " << address);
    }
    Ipv4InterfaceAddress interfaceAddress = Ipv4InterfaceAddress(address, Ipv4Mask("/24"));
    ipv4Interface->AddAddress(interfaceAddress);
}

std::string
getPath(std::string directory, std::string file)
{
    return SystemPath::Append(directory, file);
}

std::string
loadCommands(std::string path)
{
    std::ifstream commandFile(path);
    std::ostringstream commands;

    if (!commandFile)
    {
        throw std::runtime_error("Failed to open commands file: " + path);
    }

    std::string line;
    while (std::getline(commandFile, line))
    {
        commands << line << "\n";
    }

    return commands.str();
}

std::map<uint32_t, uint64_t> queueBufferSlice;

void
computeQueueBufferSlice(Ptr<P4SwitchNetDevice> p4Device)
{
    queueBufferSlice[p4Device->GetNode()->GetId()] =
        p4Device->m_mmu->DynamicThreshold(0, 0, "egress");
}

void
updateQdepth(Ptr<P4SwitchNetDevice> p4Device)
{
    uint64_t totalBufferSlice = queueBufferSlice[p4Device->GetNode()->GetId()];
    uint64_t colorSlice = (uint64_t)(totalBufferSlice / 4.0f);

    P4Pipeline* pline = p4Device->m_p4_pipeline;
    if (pline != nullptr)
    {
        std::string nodeName = p4Device->GetName();
        for (size_t p = 1; p < p4Device->GetNPorts(); ++p)
        {
            uint64_t color = 0;
            uint64_t egressBytes = p4Device->m_mmu->GetEgressBytes(p, 0);
            if (egressBytes <= colorSlice - 1)
            {
                color = 0;
            }
            else if (egressBytes >= colorSlice && egressBytes <= ((colorSlice * 2) - 1))
            {
                color = 1;
            }
            else if (egressBytes >= (colorSlice * 2) && egressBytes <= ((colorSlice * 3) - 1))
            {
                color = 2;
            }
            else if (egressBytes >= (colorSlice * 3) && egressBytes <= ((colorSlice * 4) - 1))
            {
                color = 3;
            }

            if (color > 0 && verbose)
            {
                NS_LOG_INFO("Node: " << nodeName << " Port: " << p + 1
                                     << " Egress Bytes: " << egressBytes << " Color: " << color);
            }

            pline->register_write(0, "IngressPipe.ig_qdepths", p, bm::Data(color));
        }
    }

    Simulator::Schedule(NanoSeconds(200), &updateQdepth, p4Device);
}

void
printSimulationTime()
{
    NS_LOG_INFO("Simulation Time: " << Simulator::Now().GetSeconds());
    Simulator::Schedule(Seconds(1), printSimulationTime);
}

class QLRDeparser : public P4PacketDeparser
{
  public:
    Ptr<Packet> get_ns3_packet(std::unique_ptr<bm::Packet> bm_packet)
    {
        uint8_t* bm_buf = (uint8_t*)bm_packet.get()->data();
        size_t len = bm_packet.get()->get_data_size();

        Buffer b;
        b.AddAtStart(len);
        b.Begin().Write(bm_buf, len);

        Buffer::Iterator it = b.Begin();
        EthernetHeader eth;
        eth.Deserialize(it);
        it.Next(eth.GetSerializedSize());
        size_t offset = eth.GetSerializedSize();

        uint16_t ether_type = eth.GetLengthType();

        Ipv4Header ipv4;
        TcpHeader tcp;
        UdpHeader udp;
        uint8_t next_hdr = 0;
        if (ether_type == 0x0800)
        {
            ipv4.Deserialize(it);
            it.Next(ipv4.GetSerializedSize());
            offset += ipv4.GetSerializedSize();

            next_hdr = ipv4.GetProtocol();
        }

        if (next_hdr == 6)
        {
            tcp.Deserialize(it);
            it.Next(tcp.GetSerializedSize());
            offset += tcp.GetSerializedSize();
        }
        else if (next_hdr == 17)
        {
            udp.Deserialize(it);
            it.Next(udp.GetSerializedSize());
            offset += udp.GetSerializedSize();
        }

        Ptr<Packet> p = Create<Packet>(bm_buf + offset, len - offset);
        /* Headers are added in reverse order */
        if (next_hdr == 6)
            p->AddHeader(tcp);
        else if (next_hdr == 17)
            p->AddHeader(udp);

        if (ether_type == 0x0800)
            p->AddHeader(ipv4);

        p->AddHeader(eth);

        return p;
    }
};

int
main(int argc, char* argv[])

{
    uint32_t activeFlows = 1;
    uint32_t backupFlows = 1;
    bool generateRandom = false;
    std::string defaultBandwidth = "50Kbps";
    std::string resultsPath = "examples/qlrouting/results/5-nodes";
    float flowEndTime = 11.0f;
    float endTime = 20.0f;
    std::string activeRateTcp = "50Kbps";
    std::string backupRateUdp = "50Kbps";
    uint32_t tcpDataSize = 150000000;
    uint32_t udpDataSize = 150000000;

    // Packet::EnablePrinting();

    CommandLine cmd;
    cmd.AddValue("results-path", "The path where to save results", resultsPath);
    cmd.AddValue("active-flows", "The number of concurrent flows on the active path", activeFlows);
    cmd.AddValue("backup-flows", "The number of concurrent flows on the backup path", backupFlows);
    cmd.AddValue("udp-random",
                 "Select whether UDP flows are randomly distributed.",
                 generateRandom);
    cmd.AddValue("default-bw",
                 "The bandwidth to set on all the sender/receiver links",
                 defaultBandwidth);
    cmd.AddValue("active-rate-tcp", "The TCP rate to set to the active flows", activeRateTcp);
    cmd.AddValue("backup-rate-udp", "The UDP rate to set to the backup flows", backupRateUdp);
    cmd.AddValue("flow-end", "Flows End Time", flowEndTime);
    cmd.AddValue("tcp-data-size", "Size of the data sent by TCP applications", tcpDataSize);
    cmd.AddValue("udp-data-size", "Size of the data sent by TCP applications", udpDataSize);

    cmd.AddValue("end", "Simulation End Time", endTime);
    cmd.AddValue("verbose", "Verbose output", verbose);

    cmd.Parse(argc, argv);

    LogComponentEnable("QLRoutingExample", LOG_LEVEL_INFO);
    // if (verbose)
    {
        // LogComponentEnable("FlowMonitor", LOG_LEVEL_DEBUG);
        LogComponentEnable("P4SwitchNetDevice", LOG_LEVEL_WARN);
        // LogComponentEnable("SwitchMmu", LOG_LEVEL_DEBUG);
        LogComponentEnable("P4Pipeline", LOG_LEVEL_DEBUG);
        // LogComponentEnable("TcpSocketBase", LOG_LEVEL_DEBUG);
    }

    NS_LOG_INFO("#### RUN PARAMETERS ####");
    NS_LOG_INFO("Results Path: " + resultsPath);
    NS_LOG_INFO("Flow End Time: " + std::to_string(flowEndTime));
    NS_LOG_INFO("End Time: " + std::to_string(endTime));
    NS_LOG_INFO("Backup Rate UDP: " + backupRateUdp);
    NS_LOG_INFO("Data Size UDP: " + std::to_string(udpDataSize));

    NS_LOG_INFO("Configuring Congestion Control.");
    // Config::SetDefault("ns3::TcpL4Protocol::SocketType", StringValue("ns3::" +
    // congestionControl));
    Config::SetDefault("ns3::TcpSocket::SndBufSize", UintegerValue(2 << 17));
    Config::SetDefault("ns3::TcpSocket::RcvBufSize", UintegerValue(2 << 17));
    Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(10));
    Config::SetDefault("ns3::TcpSocket::DelAckCount", UintegerValue(2));
    Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue(1400));

    std::filesystem::create_directories(resultsPath);

    randomGen = std::mt19937(seed);
    distribution = std::uniform_real_distribution(0.0, (double)flowEndTime);

    NodeContainer hosts;
    hosts.Create(5);

    NodeContainer switches;
    switches.Create(5);

    Ptr<Node> s1 = switches.Get(0);
    Names::Add("s1", s1);

    Ptr<Node> s2 = switches.Get(1);
    Names::Add("s2", s2);

    Ptr<Node> s3 = switches.Get(2);
    Names::Add("s3", s3);

    Ptr<Node> s4 = switches.Get(3);
    Names::Add("s4", s4);

    Ptr<Node> s5 = switches.Get(4);
    Names::Add("s5", s5);

    Ptr<Node> host1 = hosts.Get(0);
    Names::Add("host1", host1);

    Ptr<Node> host2 = hosts.Get(1);
    Names::Add("host2", host2);

    Ptr<Node> host3 = hosts.Get(2);
    Names::Add("host3", host3);

    Ptr<Node> host4 = hosts.Get(3);
    Names::Add("host4", host4);

    Ptr<Node> host5 = hosts.Get(4);
    Names::Add("host5", host5);

    CsmaHelper csma_sw;
    csma_sw.SetChannelAttribute("DataRate", StringValue(defaultBandwidth));
    csma_sw.SetDeviceAttribute("Mtu", UintegerValue(1500));
    // csma_sw.SetQueue("ns3::DropTailQueue", "MaxSize", StringValue(defaultBuffer));

    CsmaHelper csma_host;
    csma_host.SetChannelAttribute("DataRate", StringValue("1000Gbps"));
    csma_host.SetDeviceAttribute("Mtu", UintegerValue(1500));

    NetDeviceContainer host1Interfaces;
    NetDeviceContainer host2Interfaces;
    NetDeviceContainer host3Interfaces;
    NetDeviceContainer host4Interfaces;
    NetDeviceContainer host5Interfaces;
    NetDeviceContainer s1Interfaces;
    NetDeviceContainer s2Interfaces;
    NetDeviceContainer s3Interfaces;
    NetDeviceContainer s4Interfaces;
    NetDeviceContainer s5Interfaces;

    NetDeviceContainer link;
    link = csma_host.Install(NodeContainer(host1, s1));
    host1Interfaces.Add(link.Get(0));
    s1Interfaces.Add(link.Get(1));

    link = csma_host.Install(NodeContainer(host2, s2));
    host2Interfaces.Add(link.Get(0));
    s2Interfaces.Add(link.Get(1));

    link = csma_host.Install(NodeContainer(host3, s3));
    host3Interfaces.Add(link.Get(0));
    s3Interfaces.Add(link.Get(1));

    link = csma_host.Install(NodeContainer(host4, s4));
    host4Interfaces.Add(link.Get(0));
    s4Interfaces.Add(link.Get(1));

    link = csma_host.Install(NodeContainer(host5, s5));
    host5Interfaces.Add(link.Get(0));
    s5Interfaces.Add(link.Get(1));

    link = csma_sw.Install(NodeContainer(s1, s2));
    s1Interfaces.Add(link.Get(0));
    s2Interfaces.Add(link.Get(1));

    link = csma_sw.Install(NodeContainer(s1, s3));
    s1Interfaces.Add(link.Get(0));
    s3Interfaces.Add(link.Get(1));

    link = csma_sw.Install(NodeContainer(s2, s3));
    s2Interfaces.Add(link.Get(0));
    s3Interfaces.Add(link.Get(1));

    link = csma_sw.Install(NodeContainer(s2, s4));
    s2Interfaces.Add(link.Get(0));
    s4Interfaces.Add(link.Get(1));

    link = csma_sw.Install(NodeContainer(s3, s4));
    s3Interfaces.Add(link.Get(0));
    s4Interfaces.Add(link.Get(1));

    link = csma_sw.Install(NodeContainer(s3, s5));
    s3Interfaces.Add(link.Get(0));
    s5Interfaces.Add(link.Get(1));

    link = csma_sw.Install(NodeContainer(s4, s5));
    s4Interfaces.Add(link.Get(0));
    s5Interfaces.Add(link.Get(1));

    InternetStackHelper inetStack;
    inetStack.SetIpv4StackInstall(true);
    inetStack.SetIpv6StackInstall(false);
    inetStack.Install(hosts);

    Ipv4AddressHelper host1Ipv4Helper;
    host1Ipv4Helper.SetBase(Ipv4Address("10.0.1.0"), Ipv4Mask("/24"));
    host1Ipv4Helper.Assign(host1Interfaces);

    Ipv4AddressHelper host2Ipv4Helper;
    host2Ipv4Helper.SetBase(Ipv4Address("10.0.2.0"), Ipv4Mask("/24"));
    host2Ipv4Helper.Assign(host2Interfaces);

    Ipv4AddressHelper host3Ipv4Helper;
    host3Ipv4Helper.SetBase(Ipv4Address("10.0.3.0"), Ipv4Mask("/24"));
    host3Ipv4Helper.Assign(host3Interfaces);

    Ipv4AddressHelper host4Ipv4Helper;
    host4Ipv4Helper.SetBase(Ipv4Address("10.0.4.0"), Ipv4Mask("/24"));
    host4Ipv4Helper.Assign(host4Interfaces);

    Ipv4AddressHelper host5Ipv4Helper;
    host5Ipv4Helper.SetBase(Ipv4Address("10.0.5.0"), Ipv4Mask("/24"));
    host5Ipv4Helper.Assign(host5Interfaces);

    std::vector<Ptr<Ipv4Interface>> host1Ipv4Interfaces;
    std::vector<Ptr<Ipv4Interface>> host2Ipv4Interfaces;
    std::vector<Ptr<Ipv4Interface>> host3Ipv4Interfaces;
    std::vector<Ptr<Ipv4Interface>> host4Ipv4Interfaces;
    std::vector<Ptr<Ipv4Interface>> host5Ipv4Interfaces;

    Ptr<Ipv4Interface> host1Ipv4Interface = getIpv4Interface(host1Interfaces.Get(0));
    addIpv4Address(host1Ipv4Interface, &host1Ipv4Helper);
    host1Ipv4Interfaces.push_back(host1Ipv4Interface);

    Ptr<Ipv4Interface> host2Ipv4Interface = getIpv4Interface(host2Interfaces.Get(0));
    addIpv4Address(host2Ipv4Interface, &host2Ipv4Helper);
    host2Ipv4Interfaces.push_back(host2Ipv4Interface);

    Ptr<Ipv4Interface> host3Ipv4Interface = getIpv4Interface(host3Interfaces.Get(0));
    addIpv4Address(host3Ipv4Interface, &host3Ipv4Helper);
    host3Ipv4Interfaces.push_back(host3Ipv4Interface);

    Ptr<Ipv4Interface> host4Ipv4Interface = getIpv4Interface(host4Interfaces.Get(0));
    addIpv4Address(host4Ipv4Interface, &host4Ipv4Helper);
    host4Ipv4Interfaces.push_back(host4Ipv4Interface);

    Ptr<Ipv4Interface> host5Ipv4Interface = getIpv4Interface(host5Interfaces.Get(0));
    addIpv4Address(host5Ipv4Interface, &host5Ipv4Helper);
    host5Ipv4Interfaces.push_back(host5Ipv4Interface);

    // Add arp entries for the hosts
    addArpEntriesFromInterfaceAddresses(host1Ipv4Interface, host2Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host2Ipv4Interface, host1Ipv4Interface);

    addArpEntriesFromInterfaceAddresses(host1Ipv4Interface, host3Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host3Ipv4Interface, host1Ipv4Interface);

    addArpEntriesFromInterfaceAddresses(host1Ipv4Interface, host4Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host4Ipv4Interface, host1Ipv4Interface);

    addArpEntriesFromInterfaceAddresses(host1Ipv4Interface, host5Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host5Ipv4Interface, host1Ipv4Interface);

    addArpEntriesFromInterfaceAddresses(host2Ipv4Interface, host3Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host3Ipv4Interface, host2Ipv4Interface);

    addArpEntriesFromInterfaceAddresses(host2Ipv4Interface, host4Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host4Ipv4Interface, host2Ipv4Interface);

    addArpEntriesFromInterfaceAddresses(host2Ipv4Interface, host5Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host5Ipv4Interface, host2Ipv4Interface);

    addArpEntriesFromInterfaceAddresses(host3Ipv4Interface, host4Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host4Ipv4Interface, host3Ipv4Interface);

    addArpEntriesFromInterfaceAddresses(host3Ipv4Interface, host5Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host5Ipv4Interface, host3Ipv4Interface);

    addArpEntriesFromInterfaceAddresses(host4Ipv4Interface, host5Ipv4Interface);
    addArpEntriesFromInterfaceAddresses(host5Ipv4Interface, host4Ipv4Interface);

    P4SwitchHelper qlrHelper;
    qlrHelper.SetDeviceAttribute("PipelineJson",
                                 StringValue("/ns3/ns-3.40/examples/qlrouting/qlr_build/qlr.json"));
    qlrHelper.SetDeviceAttribute("PacketDeparser", PointerValue(CreateObject<QLRDeparser>()));

    qlrHelper.SetDeviceAttribute(
        "PipelineCommands",
        StringValue(loadCommands("/ns3/ns-3.40/examples/qlrouting/resources/5_nodes/s1.txt")));
    NetDeviceContainer s1p4Cont = qlrHelper.Install(s1, s1Interfaces);
    Ptr<P4SwitchNetDevice> s1p4 = DynamicCast<P4SwitchNetDevice>(s1p4Cont.Get(0));
    s1p4->m_mmu->SetAlphaIngress(1.0 / 8);
    s1p4->m_mmu->SetBufferPool(64 * 1024 * 1024);
    s1p4->m_mmu->SetIngressPool(64 * 1024 * 1024);
    s1p4->m_mmu->SetAlphaEgress(1.0 / 8);
    s1p4->m_mmu->SetEgressPool(64 * 1024 * 1024);
    s1p4->m_mmu->node_id = s1p4->GetNode()->GetId();
    computeQueueBufferSlice(s1p4);

    qlrHelper.SetDeviceAttribute(
        "PipelineCommands",
        StringValue(loadCommands("/ns3/ns-3.40/examples/qlrouting/resources/5_nodes/s2.txt")));
    NetDeviceContainer s2p4Cont = qlrHelper.Install(s2, s2Interfaces);
    Ptr<P4SwitchNetDevice> s2p4 = DynamicCast<P4SwitchNetDevice>(s2p4Cont.Get(0));
    s2p4->m_mmu->SetAlphaIngress(1.0 / 8);
    s2p4->m_mmu->SetBufferPool(64 * 1024 * 1024);
    s2p4->m_mmu->SetIngressPool(64 * 1024 * 1024);
    s2p4->m_mmu->SetAlphaEgress(1.0 / 8);
    s2p4->m_mmu->SetEgressPool(64 * 1024 * 1024);
    s2p4->m_mmu->node_id = s2p4->GetNode()->GetId();
    computeQueueBufferSlice(s2p4);

    qlrHelper.SetDeviceAttribute(
        "PipelineCommands",
        StringValue(loadCommands("/ns3/ns-3.40/examples/qlrouting/resources/5_nodes/s3.txt")));
    NetDeviceContainer s3p4Cont = qlrHelper.Install(s3, s3Interfaces);
    Ptr<P4SwitchNetDevice> s3p4 = DynamicCast<P4SwitchNetDevice>(s3p4Cont.Get(0));
    s3p4->m_mmu->SetAlphaIngress(1.0 / 8);
    s3p4->m_mmu->SetBufferPool(64 * 1024 * 1024);
    s3p4->m_mmu->SetIngressPool(64 * 1024 * 1024);
    s3p4->m_mmu->SetAlphaEgress(1.0 / 8);
    s3p4->m_mmu->SetEgressPool(64 * 1024 * 1024);
    s3p4->m_mmu->node_id = s3p4->GetNode()->GetId();
    computeQueueBufferSlice(s3p4);

    qlrHelper.SetDeviceAttribute(
        "PipelineCommands",
        StringValue(loadCommands("/ns3/ns-3.40/examples/qlrouting/resources/5_nodes/s4.txt")));
    NetDeviceContainer s4p4Cont = qlrHelper.Install(s4, s4Interfaces);
    Ptr<P4SwitchNetDevice> s4p4 = DynamicCast<P4SwitchNetDevice>(s4p4Cont.Get(0));
    s4p4->m_mmu->SetAlphaIngress(1.0 / 8);
    s4p4->m_mmu->SetBufferPool(64 * 1024 * 1024);
    s4p4->m_mmu->SetIngressPool(64 * 1024 * 1024);
    s4p4->m_mmu->SetAlphaEgress(1.0 / 8);
    s4p4->m_mmu->SetEgressPool(64 * 1024 * 1024);
    s4p4->m_mmu->node_id = s4p4->GetNode()->GetId();
    computeQueueBufferSlice(s4p4);

    qlrHelper.SetDeviceAttribute(
        "PipelineCommands",
        StringValue(loadCommands("/ns3/ns-3.40/examples/qlrouting/resources/5_nodes/s5.txt")));
    NetDeviceContainer s5p4Cont = qlrHelper.Install(s5, s5Interfaces);
    Ptr<P4SwitchNetDevice> s5p4 = DynamicCast<P4SwitchNetDevice>(s5p4Cont.Get(0));
    s5p4->m_mmu->SetAlphaIngress(1.0 / 8);
    s5p4->m_mmu->SetBufferPool(64 * 1024 * 1024);
    s5p4->m_mmu->SetIngressPool(64 * 1024 * 1024);
    s5p4->m_mmu->SetAlphaEgress(1.0 / 8);
    s5p4->m_mmu->SetEgressPool(64 * 1024 * 1024);
    s5p4->m_mmu->node_id = s5p4->GetNode()->GetId();
    computeQueueBufferSlice(s5p4);

    Simulator::Schedule(MilliSeconds(0), &updateQdepth, s1p4);
    Simulator::Schedule(MicroSeconds(0), &updateQdepth, s2p4);
    Simulator::Schedule(MicroSeconds(0), &updateQdepth, s3p4);
    Simulator::Schedule(MicroSeconds(0), &updateQdepth, s4p4);
    Simulator::Schedule(MicroSeconds(0), &updateQdepth, s5p4);

    NS_LOG_INFO("Create Applications.");
    NS_LOG_INFO("Create Active Flow Applications.");

    uint16_t activePort = 20000;

    // startTcpFlow(host1, host1Ipv4Interfaces, host2, activePort + 1, activeRateTcp, tcpDataSize);
    // startTcpFlow(host1, host1Ipv4Interfaces, host3, activePort + 2, activeRateTcp, tcpDataSize);
    // startTcpFlow(host1, host1Ipv4Interfaces, host4, activePort + 3, activeRateTcp, tcpDataSize);
    // startTcpFlow(host1, host1Ipv4Interfaces, host5, activePort + 4, activeRateTcp, tcpDataSize);

    // startTcpFlow(host2, host2Ipv4Interfaces, host1, activePort + 1, activeRateTcp, tcpDataSize);
    // startTcpFlow(host2, host2Ipv4Interfaces, host3, activePort + 2, activeRateTcp, tcpDataSize);
    // startTcpFlow(host2, host2Ipv4Interfaces, host4, activePort + 3, activeRateTcp, tcpDataSize);
    // startTcpFlow(host2, host2Ipv4Interfaces, host5, activePort + 4, activeRateTcp, tcpDataSize);

    // startTcpFlow(host3, host3Ipv4Interfaces, host1, activePort + 1, activeRateTcp, tcpDataSize);
    // startTcpFlow(host3, host3Ipv4Interfaces, host2, activePort + 2, activeRateTcp, tcpDataSize);
    // startTcpFlow(host3, host3Ipv4Interfaces, host4, activePort + 3, activeRateTcp, tcpDataSize);
    // startTcpFlow(host3, host3Ipv4Interfaces, host5, activePort + 4, activeRateTcp, tcpDataSize);

    // startTcpFlow(host4, host4Ipv4Interfaces, host1, activePort + 1, activeRateTcp, tcpDataSize);
    // startTcpFlow(host4, host4Ipv4Interfaces, host2, activePort + 2, activeRateTcp, tcpDataSize);
    // startTcpFlow(host4, host4Ipv4Interfaces, host3, activePort + 3, activeRateTcp, tcpDataSize);
    // startTcpFlow(host4, host4Ipv4Interfaces, host5, activePort + 4, activeRateTcp, tcpDataSize);

    startTcpFlow(host5, host5Ipv4Interfaces, host1, activePort + 1, activeRateTcp, tcpDataSize);
    // startTcpFlow(host5, host5Ipv4Interfaces, host2, activePort + 2, activeRateTcp, tcpDataSize);
    // startTcpFlow(host5, host5Ipv4Interfaces, host3, activePort + 3, activeRateTcp, tcpDataSize);
    // startTcpFlow(host5, host5Ipv4Interfaces, host4, activePort + 4, activeRateTcp, tcpDataSize);

    uint16_t backupPort = 30000;
    NS_LOG_INFO("Create Backup Flow Applications.");
    if (backupFlows > 0)
    {
        for (uint32_t i = 1; i <= backupFlows; i++)
        {
            startUdpFlow(host5,
                         host5Ipv4Interfaces,
                         host1,
                         backupPort + i,
                         backupRateUdp,
                         1.0,
                         flowEndTime,
                         udpDataSize,
                         generateRandom);
        }
    }

    // if (dumpTraffic)
    {
        std::string tracesPath = getPath(resultsPath, "traces");
        std::filesystem::create_directories(tracesPath);

        csma_sw.EnablePcapAll(getPath(tracesPath, "p4-switch"), true);
        csma_host.EnablePcapAll(getPath(tracesPath, "p4-switch"), true);
    }

    FlowMonitorHelper flowHelper;
    Ptr<FlowMonitor> flowMon = flowHelper.Install(NodeContainer(switches, hosts));

    printSimulationTime();

    NS_LOG_INFO("Run Simulation.");
    Simulator::Stop(Seconds(endTime));
    Simulator::Run();

    flowMon->CheckForLostPackets();
    Ptr<Ipv4FlowClassifier> classifier =
        DynamicCast<Ipv4FlowClassifier>(flowHelper.GetClassifier());
    auto stats = flowMon->GetFlowStats();
    for (const auto& flow : stats)
    {
        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(flow.first);
        double duration =
            flow.second.timeLastRxPacket.GetSeconds() - flow.second.timeFirstRxPacket.GetSeconds();
        double throughput = (duration > 0) ? (flow.second.rxBytes * 8.0 / duration / 1e6) : 0;
        std::cout << "Flow " << flow.first << " (" << t.sourceAddress << " -> "
                  << t.destinationAddress << ") Throughput: " << throughput << " Mbit/s"
                  << std::endl;
    }

    std::string flowMonitorPath = getPath(resultsPath, "flow-monitor");
    std::filesystem::create_directories(flowMonitorPath);
    flowMon->SerializeToXmlFile(getPath(flowMonitorPath, "flow_monitor.xml"), true, true);

    Simulator::Destroy();
    NS_LOG_INFO("Done.");
}
