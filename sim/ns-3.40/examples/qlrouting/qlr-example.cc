/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
#include "ns3/applications-module.h"
#include "ns3/core-module.h"
#include "ns3/csma-module.h"
#include "ns3/flow-monitor-helper.h"
#include "ns3/flow-monitor-module.h"
#include "ns3/internet-module.h"
#include "ns3/network-module.h"
#include "ns3/p4-switch-module.h"

#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <random>
#include <string>

using namespace ns3;

NS_LOG_COMPONENT_DEFINE("QLRoutingExample");

bool verbose = false;

uint32_t seed = 10;
std::mt19937 randomGen;
std::uniform_real_distribution distribution;

Mac48Address
convertToMacAddress(Address address)
{
    Mac48Address senderMacAddress = Mac48Address();
    senderMacAddress = senderMacAddress.ConvertFrom(address);
    return senderMacAddress;
}

void
addIpv4ArpEntry(Ptr<Ipv4Interface> interface, Ipv4Address ipv4Address, Mac48Address macAddress)
{
    Ptr<ArpCache> arpCache = interface->GetArpCache();
    ArpCache::Entry* entry = arpCache->Lookup(ipv4Address);
    if (!entry)
    {
        if (verbose)
        {
            NS_LOG_INFO("Add ARP Entry for " << "(" << ipv4Address << ", " << macAddress << ")");
        }
        entry = arpCache->Add(ipv4Address);
    }
    entry->SetMacAddress(macAddress);
    entry->MarkAutoGenerated();
}

ApplicationContainer
createTcpApplication(Ipv4Address addressToReach,
                     uint16_t port,
                     Ptr<Node> node,
                     std::string dataRate,
                     uint32_t maxBytes,
                     std::string congestionControl)
{
    TypeId congestionControlTid = TypeId::LookupByName(congestionControl);

    Config::Set("/NodeList/" + std::to_string(node->GetId()) + "/$ns3::TcpL4Protocol/SocketType",
                TypeIdValue(congestionControlTid));

    OnOffHelper source("ns3::TcpSocketFactory", Address(InetSocketAddress(addressToReach, port)));
    source.SetConstantRate(DataRate(dataRate), 1400);
    // source.SetAttribute("DataRate", StringValue(dataRate));
    source.SetAttribute("MaxBytes", UintegerValue(maxBytes));
    // source.SetAttribute("SendSize", UintegerValue(1400));

    return source.Install(node);
}

ApplicationContainer
createSinkTcpApplication(uint16_t port, Ptr<Node> node)
{
    PacketSinkHelper sink("ns3::TcpSocketFactory",
                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));
    return sink.Install(node);
}

Ptr<Ipv4Interface>
getIpv4Interface(Ptr<NetDevice> netDevice)
{
    Ptr<Node> node = netDevice->GetNode();
    int32_t interface_index = node->GetObject<Ipv4>()->GetInterfaceForDevice(netDevice);
    return node->GetObject<Ipv4L3Protocol>()->GetInterface(interface_index);
}

void
printRoutes(Ptr<Ipv4StaticRouting> routing)
{
    for (uint32_t i = 0; i < routing->GetNRoutes(); i++)
    {
        std::ostringstream oss;
        oss << routing->GetRoute(i);
        std::cout << oss.str() << std::endl;
    }
}

void
addArpEntriesFromInterfaceAddresses(Ptr<Ipv4Interface> nodeInterface,
                                    Ptr<Ipv4Interface> ipv4Interface)
{
    Ipv4StaticRoutingHelper ipv4StaticRouting;
    Ptr<Ipv4StaticRouting> routing = ipv4StaticRouting.GetStaticRouting(
        nodeInterface->GetDevice()->GetNode()->GetObject<Ipv4>());
    for (uint32_t i = 0; i < ipv4Interface->GetNAddresses(); i++)
    {   
        Ipv4Address address = ipv4Interface->GetAddress(i).GetAddress();
        std::cout << "Add ARP Entry for " << address << std::endl;
        addIpv4ArpEntry(nodeInterface,
                        address,
                        convertToMacAddress(ipv4Interface->GetDevice()->GetAddress()));

        routing->AddHostRouteTo(address, 1);
    }

    // if (verbose)
    {
        std::cout << "Routes for " << Names::FindName(nodeInterface->GetDevice()->GetNode())
                  << std::endl;
        printRoutes(routing);
    }
}

void
addIpv4Address(Ptr<Ipv4Interface> ipv4Interface, Ipv4AddressHelper* ipv4AddressHelper)
{
    Ipv4Address address = ipv4AddressHelper->NewAddress();
    if (verbose)
    {
        NS_LOG_INFO("Add IPv4 Address: " << address);
    }
    Ipv4InterfaceAddress interfaceAddress = Ipv4InterfaceAddress(address, Ipv4Mask("/24"));
    ipv4Interface->AddAddress(interfaceAddress);
}

std::string
getPath(std::string directory, std::string file)
{
    return SystemPath::Append(directory, file);
}

class QLRDeparser : public P4PacketDeparser
{
  public:
    Ptr<Packet> get_ns3_packet(std::unique_ptr<bm::Packet> bm_packet)
    {
        uint8_t* bm_buf = (uint8_t*)bm_packet.get()->data();
        size_t len = bm_packet.get()->get_data_size();

        Buffer b;
        b.AddAtStart(len);
        b.Begin().Write(bm_buf, len);

        Buffer::Iterator it = b.Begin();
        EthernetHeader eth;
        eth.Deserialize(it);
        it.Next(eth.GetSerializedSize());
        size_t offset = eth.GetSerializedSize();

        uint16_t ether_type = eth.GetLengthType();

        Ipv4Header ipv4;
        TcpHeader tcp;
        UdpHeader udp;
        uint8_t next_hdr = 0;
        if (ether_type == 0x0800)
        {
            ipv4.Deserialize(it);
            it.Next(ipv4.GetSerializedSize());
            offset += ipv4.GetSerializedSize();

            next_hdr = ipv4.GetProtocol();
        }

        if (next_hdr == 6 || next_hdr == 152)
        {
            tcp.Deserialize(it);
            it.Next(tcp.GetSerializedSize());
            offset += tcp.GetSerializedSize();
        }
        else if (next_hdr == 17 || next_hdr == 163)
        {
            udp.Deserialize(it);
            it.Next(udp.GetSerializedSize());
            offset += udp.GetSerializedSize();
        }

        Ptr<Packet> p = Create<Packet>(bm_buf + offset, len - offset);
        /* Headers are added in reverse order */
        if (next_hdr == 6 || next_hdr == 152)
            p->AddHeader(tcp);
        else if (next_hdr == 17 || next_hdr == 163)
            p->AddHeader(udp);

        if (ether_type == 0x0800)
            p->AddHeader(ipv4);

        p->AddHeader(eth);
        
        p->Print(std::cout);
        
        return p;
    }
};

int
main(int argc, char* argv[])

{
    uint32_t activeFlows = 1;
    std::string defaultBandwidth = "50Kbps";
    std::string resultsPath = "examples/qlrouting/results/";
    float flowEndTime = 11.0f;
    float endTime = 20.0f;
    std::string activeRateTcp = "50Kbps";
    uint32_t maxBytes = 15000000;

    Packet::EnablePrinting();


    CommandLine cmd;
    cmd.AddValue("results-path", "The path where to save results", resultsPath);
    cmd.AddValue("active-flows", "The number of concurrent flows on the active path", activeFlows);
    cmd.AddValue("default-bw",
                 "The bandwidth to set on all the sender/receiver links",
                 defaultBandwidth);
    cmd.AddValue("flow-end", "Flows End Time", flowEndTime);
    cmd.AddValue("end", "Simulation End Time", endTime);
    cmd.AddValue("verbose", "Verbose output", verbose);

    cmd.Parse(argc, argv);

    LogComponentEnable("QLRoutingExample", LOG_LEVEL_INFO);
    // if (verbose)
    {
        // LogComponentEnable("FlowMonitor", LOG_LEVEL_DEBUG);
        // LogComponentEnable("P4SwitchNetDevice", LOG_LEVEL_DEBUG);
        LogComponentEnable("TcpSocketBase", LOG_LEVEL_DEBUG);
    }

    NS_LOG_INFO("#### RUN PARAMETERS ####");
    NS_LOG_INFO("Results Path: " + resultsPath);
    NS_LOG_INFO("Flow End Time: " + std::to_string(flowEndTime));
    NS_LOG_INFO("End Time: " + std::to_string(endTime));

    NS_LOG_INFO("Configuring Congestion Control.");
    // Config::SetDefault("ns3::TcpL4Protocol::SocketType", StringValue("ns3::" +
    // congestionControl));
    Config::SetDefault("ns3::TcpSocket::SndBufSize", UintegerValue(2 << 17));
    Config::SetDefault("ns3::TcpSocket::RcvBufSize", UintegerValue(2 << 17));
    Config::SetDefault("ns3::TcpSocket::InitialCwnd", UintegerValue(10));
    Config::SetDefault("ns3::TcpSocket::DelAckCount", UintegerValue(2));
    Config::SetDefault("ns3::TcpSocket::SegmentSize", UintegerValue(1400));
    Config::SetDefault("ns3::FifoQueueDisc::MaxSize", QueueSizeValue(QueueSize("100p")));

    std::filesystem::create_directories(resultsPath);

    randomGen = std::mt19937(seed);
    distribution = std::uniform_real_distribution(0.0, (double)flowEndTime);

    NodeContainer senders;
    senders.Create(activeFlows);

    NodeContainer receivers;
    receivers.Create(activeFlows);

    NodeContainer switches;
    switches.Create(2);

    Ptr<Node> s1 = switches.Get(0);
    Names::Add("s1", s1);

    Ptr<Node> s2 = switches.Get(1);
    Names::Add("s2", s2);

    Ptr<Node> sender = senders.Get(0);
    Names::Add("sender", sender);

    Ptr<Node> receiver = receivers.Get(0);
    Names::Add("receiver", receiver);

    CsmaHelper csma;
    csma.SetChannelAttribute("DataRate", StringValue(defaultBandwidth));
    csma.SetDeviceAttribute("Mtu", UintegerValue(1500));
    // csma.SetQueue("ns3::DropTailQueue", "MaxSize", StringValue(defaultBuffer));

    NetDeviceContainer senderInterfaces;
    NetDeviceContainer receiverInterfaces;
    NetDeviceContainer s1Interfaces;
    NetDeviceContainer s2Interfaces;

    NetDeviceContainer link;
    for (uint32_t i = 0; i < activeFlows; i++)
    {
        Ptr<Node> sender = senders.Get(i);
        link = csma.Install(NodeContainer(sender, s1));
        senderInterfaces.Add(link.Get(0));
        s1Interfaces.Add(link.Get(1));
    }

    link = csma.Install(NodeContainer(s1, s2));
    s1Interfaces.Add(link.Get(0));
    s2Interfaces.Add(link.Get(1));

    for (uint32_t i = 0; i < activeFlows; i++)
    {
        Ptr<Node> receiver = receivers.Get(i);
        link = csma.Install(NodeContainer(receiver, s2));
        receiverInterfaces.Add(link.Get(0));
        s2Interfaces.Add(link.Get(1));
    }

    InternetStackHelper inetStack;
    inetStack.SetIpv4StackInstall(true);
    inetStack.SetIpv6StackInstall(false);
    inetStack.Install(senders);
    inetStack.Install(receivers);

    Ipv4AddressHelper senderIpv4Helper;
    senderIpv4Helper.SetBase(Ipv4Address("10.0.1.0"), Ipv4Mask("/24"));
    senderIpv4Helper.Assign(senderInterfaces);

    Ipv4AddressHelper receiverIpv4Helper;
    receiverIpv4Helper.SetBase(Ipv4Address("10.0.2.0"), Ipv4Mask("/24"));
    receiverIpv4Helper.Assign(receiverInterfaces);

    std::vector<Ptr<Ipv4Interface>> senderIpv4Interfaces;
    std::vector<Ptr<Ipv4Interface>> receiverIpv4Interfaces;
    for (uint32_t i = 0; i < activeFlows; i++)
    {
        Ptr<Ipv4Interface> senderIpv4Interface = getIpv4Interface(senderInterfaces.Get(i));
        addIpv4Address(senderIpv4Interface, &senderIpv4Helper);
        senderIpv4Interfaces.push_back(senderIpv4Interface);

        Ptr<Ipv4Interface> receiverIpv4Interface = getIpv4Interface(receiverInterfaces.Get(i));
        addIpv4Address(receiverIpv4Interface, &receiverIpv4Helper);
        receiverIpv4Interfaces.push_back(receiverIpv4Interface);

        addArpEntriesFromInterfaceAddresses(senderIpv4Interface, receiverIpv4Interface);
        addArpEntriesFromInterfaceAddresses(receiverIpv4Interface, senderIpv4Interface);
    }

    P4SwitchHelper qlrHelper;
    qlrHelper.SetDeviceAttribute("PipelineJson",
                                 StringValue("/ns3/ns-3.40/examples/qlrouting/qlr_build/qlr.json"));
    qlrHelper.SetDeviceAttribute("PacketDeparser", PointerValue(CreateObject<QLRDeparser>()));


    std::ostringstream s1Commands; 
    s1Commands << "register_write row2 0 256\n"
    << "table_add qlr_pkt_updates qlr_pkt_set_1 2 2 =>\n" 
    << "table_add read_ig_qdepth get_ig_qdepth_and_idx 2 => 1\n"
    << "table_add select_port_from_row_col set_nhop 2 1 => 2\n"
    << "table_add select_row get_row_num 10.0.2.0/24 => 2\n"
    << "table_set_default select_row set_nhop_and_clear_qlr 1";

    qlrHelper.SetDeviceAttribute("PipelineCommands", StringValue(s1Commands.str()));
    NetDeviceContainer s1p4Cont = qlrHelper.Install(s1, s1Interfaces);
    Ptr<P4SwitchNetDevice> s1p4 = DynamicCast<P4SwitchNetDevice>(s1p4Cont.Get(0));
    s1p4->m_mmu->SetAlphaIngress(1.0 / 8);
    s1p4->m_mmu->SetBufferPool(64 * 1024 * 1024);
    s1p4->m_mmu->SetIngressPool(64 * 1024 * 1024);
    s1p4->m_mmu->SetAlphaEgress(1.0 / 8);
    s1p4->m_mmu->SetEgressPool(64 * 1024 * 1024);
    s1p4->m_mmu->node_id = s1p4->GetNode()->GetId();

    std::ostringstream s2Commands; 
    s2Commands << "register_write row1 0 1\n"
    << "table_add qlr_pkt_updates qlr_pkt_set_2 1 1 =>\n" 
    << "table_add read_ig_qdepth get_ig_qdepth_and_idx 1 => 0\n"
    << "table_add select_port_from_row_col set_nhop 1 0 => 1\n"
    << "table_add select_row get_row_num 10.0.1.0/24 => 1\n"
    << "table_set_default select_row set_nhop_and_clear_qlr 2";
    qlrHelper.SetDeviceAttribute("PipelineCommands", StringValue(s2Commands.str()));

    NetDeviceContainer s2p4Cont = qlrHelper.Install(s2, s2Interfaces);
    Ptr<P4SwitchNetDevice> s2p4 = DynamicCast<P4SwitchNetDevice>(s2p4Cont.Get(0));
    s2p4->m_mmu->SetAlphaIngress(1.0 / 8);
    s2p4->m_mmu->SetBufferPool(64 * 1024 * 1024);
    s2p4->m_mmu->SetIngressPool(64 * 1024 * 1024);
    s2p4->m_mmu->SetAlphaEgress(1.0 / 8);
    s2p4->m_mmu->SetEgressPool(64 * 1024 * 1024);
    s2p4->m_mmu->node_id = s2p4->GetNode()->GetId();

    NS_LOG_INFO("Create Applications.");
    NS_LOG_INFO("Create Active Flow Applications.");
    uint16_t activePort = 20000;

    if (activeFlows > 0)
    {
        ApplicationContainer activeReceiverApp =
            createSinkTcpApplication(activePort, receivers.Get(0));
        activeReceiverApp.Start(Seconds(0.0));
        activeReceiverApp.Stop(Seconds(flowEndTime + 1));

        ApplicationContainer activeSenderApp =
            createTcpApplication(receiverIpv4Interfaces[0]->GetAddress(1).GetAddress(),
                                 activePort,
                                 senders.Get(0),
                                 activeRateTcp,
                                 maxBytes,
                                 "ns3::TcpCubic");
        activeSenderApp.Start(Seconds(1.0));
    }

    // if (dumpTraffic)
    {
        std::string tracesPath = getPath(resultsPath, "traces");
        std::filesystem::create_directories(tracesPath);

        csma.EnablePcapAll(getPath(tracesPath, "p4-switch"), true);
    }

    NS_LOG_INFO("Run Simulation.");
    Simulator::Stop(Seconds(endTime));
    Simulator::Run();

    Simulator::Destroy();
    NS_LOG_INFO("Done.");
}
